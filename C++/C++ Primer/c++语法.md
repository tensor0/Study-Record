1. extern和.h文头文件的区别与联系 (以下三篇均未看)
    1. https://blog.csdn.net/mosepplin/article/details/130682603
    2. https://www.cnblogs.com/alionxd/articles/3200176.html
    3. https://www.runoob.com/w3cnote/extern-head-h-different.html
2. split函数

c++面试题：
https://zhuanlan.zhihu.com/p/575926443

###  c++primer
1. endl p6
2. 字符字面值，字符串字面值 p36
3. c++中，初始化和赋值是两个不同的操作 p39
4. 默认初始化 p40
5. 变量的声明和定义 p41
    定义和初始化和赋值有什么区别？
    ```cpp
    int j;//声明并且定义j
    extern int j; //仅声明j
    extern int j = 1; //extern关键字失效，变成了声明并定义j
    ```
6. 静态类型:在编译阶段检查类型 p42
7. 变量命名规范 p42
8. 变量的作用域：p44
    1. 作用域可以被嵌套，并且允许在内层作用域中重新定义外层作用域中已有的名字 
    2. 全局作用域的表达方式：：
    3. p45练习题
9. 引用：**引用是已经存在的对象的别名,引用并不是对象** p46
    没有
    ```cpp
    int &i=10;//是错误的，因为引用只能和对象绑定，是对象的别名，而不能是字面值的别名

    double dval=3.14;
    int& val=dval;//是错误的，因为引用类型和绑定的对象要严格匹配
    ```
10. 指针 p47
    因为引用不是对象，所以没有实际的地址，所以不能定义指向引用的指针
    ```cpp
    int j, &i = j;
    int& *p = i;//错误，因为此时p是指向int&类型的指针，但是引用不是对象，没有实际的地址，不能这样定义
    ```
    ```cpp
    int i = 5;
    int &ival = i;
    int *p = &ival;//这里是val虽然是引用，但是&val是val绑定对象的地址，所以p是指向对象的地址,是正确的
    ```
11. 编译器怎么&与*后的是引用还是指针还是取地址还是解引用？ p48
12. 空指针 p48
    ```cpp
    //以下三种都可以
    int *p1 = nullptr;
    int *p2 = 0;
    int *p3 = NULL;
    ```
    但是
    ```cpp
    int zero = 0;
    int *p = zero;//是错误的，因为类型不匹配
    ```
13. 指针与逻辑运算 p50
    1. 指针合法，但不是空指针，逻辑值为true
    2. 指针合法，是空指针，逻辑值为false;
    ```cpp
    int val = 1024;
    int *pi = 0;
    int *pi2 = &val;
    if(pi)//false

    if(pi2)//true
    ```
14. 指针的比较 p50
15. 复合类型的声明 p51
16. 指向指针的指针 p52
    ```cpp
    int ***i;//含义见p52，重点理解int以及***组成了复合数据类型
    ```
17. 指针的引用 p52
    重点是理解对复杂指针或引用要从右向左读 p53
    **从右向左阅读r的定义，离变量名最近的符号对变量名类型有最直接的影响，声明符的其余部分用以确定r引用的类型是什么**
    ```cpp
    int *p;
    int *&r=p;//从右往左，r首先是一个引用，发现其余部分是"int*"，所以r是指向int类型指针的引用
    int ***p1;//从右往左，p1首先是一个指针，发现其余部分是int **,所以p1是指向int类型的二级指针的指针
    ```
18. const限定符
    1. const和初始化 p53 
    2. onst的引用和初始化 p55
    3. 指针和const(指针常量和常量指针) p56
    4. constexpr：为了验证变量是否是常量表达式,这样的话可以用编译器在编译阶段计算出结果，优化运行时间 p58
        1. constexpr可以修饰指针的引用，但是初始值受到严格限制，参见p59下
19. typedef p60
        易错 p61
20. auto：让编译器通过初始值来推断变量的类型(所以auto定义的变量必须有初始值) p61
        （auto后面没详细看用法）
21. decltype：通过表达式的类型推断出要定义的类型，但是并不想用该表达式的值初始化变量 p62
    1. 如果表达式内容是解引用操作，则decltype得到引用类型
        ```cpp
        int p,j;
        decltype(*p) i=j;//i为引用类型，所以必须初始化
        ```
    2. decltpye中的变量(注意不是表达式，是单独一个变量)如果多加一个括号，则得到引用类型
        ```cpp
        int i,j;
        decltype((i+j)) k=j;//j是int类型
        decltype((i)) m=j;//m是int&类型
        ```
22. 自定义数据结构struct(但是没说什么有用的东西，只提了一下概念)
23. 头文件和预处理
    头文件保护符
        ```cpp
        #ifndef 
        #define

        #endif
        ```
###  第三章字符串、向量和数组
1. 命名空间的using声明
    ```cpp
    using std::cin;//using声明，当我们使用名字cin时，从命名空间std中获取它
    ```
    1. 每个名字都需要using声明
2. 直接初始化：不使用等号初始化对象
    拷贝初始化：使用等号初始化对象
    ```cpp
    string s5 = "hiya";//拷贝初始化
    string s6("hiya");//直接初始化
    string s7(10,'c');//直接初始化
    ```
    对多个值使用拷贝初始化
    ```cpp
    string s8 = string(10,'c');//拷贝初始化(显式地创建一个临时对象用于拷贝,但是可读性较差)
    ```
3. 读写string对象：使用cin将标准输入的内容读取到string类的对象s中时，string对象会自动忽略开头的空白(即空格符、换行符、制表符等)并从第一个真正的字符开始读起，直到遇见下一个空白为止 p78
    ```cpp
    ```
    2. 读取未知数量的string对象
    3. 使用getline函数读取一行
    4. string::size_type类型(string类中定义的配套类型，体现了标准库类型与机器无关的特性,可以用auto和decltype推断)
    5. string对象的比较(==、!=、<、<=、>、>=)
    6. string对象赋值
    7. 两个string对象相加
    8. 字面值和string对象相加
    9. 处理string对象中的字符:cctype头文件中的函数
4. 范围for: **range for**(c++11) p82
    1. 示例：
    ```cpp
    for(declaration:expression)
        statement
    ```
    ```cpp
    string str("some string");
    for(auto c:str)//每次迭代，str的下一个字符被拷贝给c
    {
        cout << c << endl;
    }
    ```
    其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。
    2. 使用范围for改变字符串中的字符
    ```cpp
    string s("Hello World!!!");
    for(auto& c:s)//对于s中的每一个字符
    {
        c = toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值
    }
    cout << c << endl;
    ```
5. 

















10. 数组：p101
    1. 数组的声明形如a[d]，其中a是数组的名字，d是数组的维度。编译的时候，数组的维度应该是已知的,所以**数组的维度必须是一个常量表达式**(变量不可以)。
    2. **定义数组的时候必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型。** p102
    3. **和vector一样，数组的元素应为对象，因此不存在引用的数组** (理由见p47)p102
        ```cpp
        int& a[10];//是错误的，因为数组元素的类型不能是int&类型
        ```
    4. 显示初始化数组：允许忽略数组的维度。如果在声明的时候没有指明维度，编译器会根据初始值的数量计算并推测出来;
        ```cpp
        const unsigned sz = 3;
        int ial[sz] = {0, 1, 2};//含有3个元素的数组，元素值分别为0,1,2
        int a2[] = {0, 1, 2};//维度是3的数组(编译器计算出)
        int a3[5] = {0, 1, 2};//等价于a3[] = {0, 1, 2, 0, 0}
        string a4[3] = {"hi", "bye"};//等价于a4[] = {"hi", "bye", ""}
        int a5[2] = {0, 1, 2};//错误，初始值过多
        ```
    默认情况下，数组被默认初始化
    5. 字符数组的特殊性：
    **字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组进行初始化**(但是普通数组只能一个元素一个元素进行赋值)。当使用这种方式时，一定要注意也会像字符串的其他字符一样被拷贝到字符数组中去：
    ```cpp
    char a1[] = {'C','+','+'};//列表初始化，没有空字符，cout时不会停止，直到遇到'\0'
    char a2[] = {'C','+','+','\0'};//列表初始化，含有显式的空字符
    char a3[] = "C++";//自动添加表示字符串结束的空字符串(其实"C++"是char[4]类型，结尾有'\0')
    const char a4[6] = "Daniel";//错误，没有空间可以放空字符(vscode会提示const char [7]类型不能用于初始化const char[6]类型的实体)
    ```

    注意：'\0'和' '代表的字符不是一个:

            '\0'的acsii码是0
            ' '的acsii码是32
            '\0'为字符串的结尾标志
    6. 数组不允许拷贝和赋值
    ```cpp
    int a[] = {0, 1, 2};
    int a2[] = a;//错误，不允许使用一个数组初始化另外一个数组
    a2 = a;//错误，不能把一个数组直接复制给另一个数组
    ```
    7. 理解复杂的数组声明
    ```cpp
    int *ptrs[10];//ptrs是含有10个整型只针对数组
    int &refs[10] = /* ? */;//错误：不存在引用的数组
    int (*Parray)[10] = &arr;//Parray指向一个含有10个整数的数组
    int (&arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组
    ```
    这里就不能用从右往左读的办法了：
    因为数组名和下标是一起的，所以先指出ptrs是谁的名字，例如：
    ```cpp
    int *ptrs[10];//ptrs和维度是一个整体，所以ptrs是数组的名字，然后再往左看，每个数组元素都是int*类型
    int (*Parray)[10];//由于加了括号，所以先看*Parray，说明Parray先是一个指针，然后看他是什么指针，由于括号出来后和数组的维度是一个整体，所以他是数组的指针，再往左看，这个数组元素的类型是int，所以Parray是指向int类型数组的指针
    int (&arrRef)[10] = arr;//同上
    ```
    8. **指针和数组：数组的另一个特性，在很多用到数组名字的地方，编译器会自动地将其替换为一个指向数组首元素的指针** p105
        ```cpp
        string nums[] = {"one", "two", "three"};
        string *p = &nums[0];
        string *p2 = nums;//等价于p2 = &nums[0]
        ```
        1. 但是数组名不是地址，名字怎么能是地址呢？如果说数组名所绑定的内存是存地址的变量(数组名是指针)，这也不对，因为a实际上是a[0]的地址，但是sizeof(a)得到数组a的大小
        ```cpp
        int ia[] = {0, 1, 2};
        auto ia2(ia);//因为ia被编译器转换为指向第一个元素的指针，auto推导出类型是int*，所以ia2是一个整型指针，指向ia的第一个元素
        ia2 = 42;//错误：ia2是一个整型指针，不能用int值给指针赋值
        ```
        2. **但是，decltype关键字不会自动将数组名字替换成一个指向数组第一个元素的指针：**
        ```cpp
        decltype(ia) ia3//ia3是一个int [3]类型的数组
        ```
        3. 下标和指针：
        如前所述，在很多情况下使用数组的名字其实用的是一个指向数组第一个元素的指针。
        **一个典型的例子是当对数组使用下标运算时，编译器会自动执行上述转换操作。**
        ```cpp
        int ia[] = {0, 1, 2};
        ia[0]//此时ia[0]是一个使用了数组名字的表达式
        //对数组执行下标运算其实是对指向数组元素的指针执行下标运算
        int i = ia[2];//等价于 i=*(ia+2)
        //1.ia转换成指向数组首元素的指针
        //2. ia[2]得到(ia+2)所指的元素，即*(ia+2)
        ```
    **只要是指针指向的是数组中的元素(或者数组中尾元素的下一位置)，都可以执行下标运算**
    ```cpp
    int *p = &ia[2];//p指向ia数组中索引为2的元素
    int j = p[1];//p[1]等价于*(p+1)，也就是ia[3]的那个元素
    int k = p[-2];//p[-2]是ia[0]表示的那个元素
    ```
    **虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。**
11. C风格字符串 p109
12. 多维数组 p112

###  第四章 表达式

###  第五章 语句

###  第六章 函数
**函数是一个命名了的代码块**
1. 函数基础：
    1. 调用运算符 p182
    2. 函数的调用完成两项工作：
        ```
        1. 用实参初始化函数对应的形参
        2. 将控制权转移给被调用函数
        ```
    3. 没有规定实参的求值顺序 p183
    4. 函数的返回类型不能是数组类型或者函数类型 p184
2. 局部对象：
    1. 自动对象：只存在于块执行期间的对象(如函数形参)
    2. 局部静态对象：有些时候，有必要令局部变量的生命周期贯穿函数调用及以后的时间。可以将局部变量定义成static类型从而获得这样的对象
3. 函数声明: p186
    1. 类比于变量，函数可以声明多次，但是只能定义一次。和变量一样，如果一个函数永远不会被用到，那么可以只声明而没有定义
    2. 因为函数的声明不包含函数体，所以也就无须形参的名字。但是写上形参的名字更加清楚函数的功能
    3. 函数声明也被称作函数原型
    4. 在头文件中应当进行函数声明
    5. 定义函数的源文件时应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配



###  第七章 类
1. this指针的引入 p231
    对于成员函数，我们怎么知道要返回的成员变量是属于哪一个对象呢？
    其实在调用成员函数时，我们使用了点运算符来访问total对象的isbn成员，然后调用它。
    当我们调用某个成员函数时，实际上是在替某个对象调用它。成员函数隐式地指向调用该函数的对象的成员。
    实现原理：
    成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用
    ```cpp
    total.isbn()
    ```
    则编译器负责把total的地址传递给了isbn的隐式形参this，可以等价地认为编译器将该调用重写成了如下形式：
    ```cpp
    Sales_data::isbn(&total)
    ```
2. this指针默认是指向非常量的常量指针，所以默认情况下this不能指向常量对象，我们要想让this指向的对象不可改变，那么我们要把this指针改成指向常量的指针，可是this是隐式的不会出现在参数列表中，所以c++把const关键字放在成员函数的参数列表之后(花括号之前),此时表名该成员函数的this指针是一个指向常量的指针。该成员函数被称为常量成员函数。p231-232
3. 指向常量的指针 p56
    1. 指向常量的指针可以指向非常量，但是此时并不能用该指针去修改非常量的值。
    2. 但是普通指针不能指向常量(因为可以通过普通指针修改指针指向的值，但是指针指向的值却是常量，这就产生矛盾，所以不行)。
    因为打个比方，所谓指向常量的指针或引用，不过是指针或引用自己认为自己指向了常量。所以第一种情况下不能用指向常量的指针去修改非常量的值。
4. 类本身是一个作用域,因为c++中作用域基本上以花括号分割，类的定义被花括号包含 p232
5. 编译顺序：p232
    和成员变量以及成员函数的先后无关，编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体(如果有的话)
6. **构造函数：p235**
    ```cpp
        任务：
        初始化类对象的数据成员，只要类的对象被创建，就会执行构造函数

        注意事项：
        1. 类可以包含多个构造函数，因为构造函数也可以重载
        2. 构造函数不能声明为const，因为构造函数完成初始化的过程和该成员函数声明为const相矛盾(声明为const后，this指针认为自己指向的是常量对象，不可对其更改，与构造函数初始化赋值的过程矛盾)。其次，当创建一个类的const对象时，直到构造函数完成初始化过程，对象才能真正取得"常量"属性。因此构造函数在const对象的构造过程中可以向其写值
        分类：
    ```
    ```cpp
    首先注意区分构造函数和默认构造函数和合成的默认构造函数概念
        默认构造函数：
        类通过一个特殊的函数来控制默认初始化过程，这个函数叫做默认构造函数。默认构造函数无须任何实参。
        合成的默认构造函数：p236
        编译器创建的构造函数被称为合成的默认构造函数，对象执行默认初始化时执行的构造函数就是合成的默认构造函数(该函数不用显示定义，由编译器自动合成)
        
        注：1. 默认构造函数分两种，一种是自己定义的，一种是编译器创建的，只有编译器创建的默认构造函数才叫做合成的默认构造函数
            2. 默认构造函数没有实参，需要参数的不叫默认构造函数


        执行规则：
        1.如果存在类内的初始值，则用初始值初始化成员
        2.否则，默认初始化该成员
        意思为如果类的定义中成员变量有初值的，那么合成默认构造函数会用该初值初始化有初值的成员，若某个成员没有初值，则会按照默认初始化的规则初始化这个成员

        默认初始化规则：p40
        内置类型的变量如果在函数体外定义则被初始化为0，函数体内定义那么该变量的值是未定义(未知的值)，如果是类的对象没有显式初始化，则根据该类的自身的默认构造函数确定初始化的值？如果该类禁止默认初始化，则会产生错误，所以一个类(记为A类)中如果包含一个禁止默认初始化的类，那么要对A类自定义默认构造函数，否则该类则没有可用的默认构造函数(根据p40和p236自己理解的)

        注意事项：
        只有当类没有声明任何构造函数时，编译器才会自动地生成合成的默认构造函数，否则此时将没有默认构造函数，因为编译器不会帮你自动生成，并且此时也没有自己定义默认构造函数(这条规则的依原因是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制(所以编译器不给你自动生成，需要自己控制))

        简要来说，编译器不能自动生成合成的默认构造函数的情况有两种：
        1. 该类已经声明其他构造函数
        2. 该类(A类)中包含禁止生成默认构造函数的类(B类)，而A类中的默认构造函数也未对B类的初始化作定义

    ```
7. 访问控制与封装p240
    定义在public说明符后的成员在整个程序内都可以被访问
    定义在private说明符之后的成员可以被类的成员函数访问

    class和struct定义类的唯一区别就是默认的访问权限：
    struct默认public
    class默认private

8. 友元 p241
    目的：
    如果想让其他类或者函数
    类可以允许其他类或者函数访问他的非公有成员，方法是令其他类或者函数称为它的友元
    用法：
    如果类想把一个函数作为它的友元，那么在类内增加friend关键字开始的函数声明语句
    注意事项：
    上述用法中friend关键字的声明只是指定了访问的权限，并非一个通常意义的函数声明，所以我们需要在类内的友元声明外专门对函数进行一次声明(就像一般情况下需要对函数进行声明才可以调用函数)

9. 成员函数的内联 p244
    类内定义的成员函数：
    定义在类内部的成员函数是自动inline的

    类外定义的成员函数：
    在类外定义前加inline关键字

10. 成员函数的重载 p245
    和普通函数的重载一样

11. 可变的数据成员(mutable data member) p245
    mutable关键字
    目的：我们希望修改类的某个数据成员，即使是在一个const成员函数内(即使该成员函数的this指针是const的),可以通过在变量的声明中加入mutable关键字做到这一点

    一个可变的数据成员永远不会时const，即使它是const对象的成员变量
    ```
12. 返回*this的成员函数 p247
    由于成员函数move的返回值类型是*this,所以可以
    ```cpp
    //执行完myScreen.move(4.0)后返回该对象本身，所以可以继续执行.set('#')
    myScreen.move(4.0).set('#');
    //上述语句等价于执行以下语句
    myScreen.move(4.0);
    myScreen.set('#');

    //若move的返回值是Screen类型而非Screen&类型,则行为大不相同
    Screen temp = myScreen.move(4.0);//对返回值进行拷贝
    temp.set('#');//修改的是拷贝后的temp对象，而并不是myScreen对象本身
    ```
13. 从const成员函数(指的是该成员函数的this指针被const修饰)返回*this
    此时，this是一个指向const的指针而*this是const对象,所以
    ```
    Screen myScreen;
    //如果display返回常量引用，则调用set将引发错误(因为set函数的this指针并非被const修饰)
    myScreen.display(cout).set('*');
    ```
14. 基于const的重载 p247
    对于常量变量来说，不能调用非常量版本的函数
    对于非常量变量来说，虽然可以调用常量版本的函数和非常量版本的函数，但是此时非常量版本的函数是一个更好的匹配
15. 类类型 p249
    每一个类定义了唯一的类型，即使这两个类的成员完全一样。
    类的声明：
    类可以像函数的声明和定义分开一样，我们可以只声明类而暂时不定义它
16. 友元再探





17. 再谈引用
    c++引用的由来：
    ```cpp
    //如果没有引用，用指针来进行运算符重载
    A operator+(cosnt A* a, const A* b)
    {
        return *a+*b;
    }
    //使用+的重载的时候，只能是
    &a+&b//因为要给重载函数传地址，但是这样写不美观
    //所以引入引用解决了问题
    A operator+(cosnt A& a, const A& b)
    {
        return a+b;
    }
    //引入引用后的运算符重载
    a+b   
    ```















###  第十五章 面向对象程序设计
1. 面向对象三大特性：
    封装(数据抽象)，继承，多态(动态绑定)
    1. 封装：
        **注解：**
        封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项，或者叫接口。有了封装，就可以明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者；而外部调用者也可以知道自己不可以碰哪里。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。
    2. 继承：
        **概念：(继承的概念，基类的概念，派生类的概念)**
        通过**继承**联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。
        **注解：**
        继承同时具有两种含义：其一是继承基类的方法，并做出自己的改变和/或扩展——号称解决了代码重用问题；其二是声明某个子类兼容于某基类（或者说，接口上完全兼容于基类），外部调用者可无需关注其差别（内部机制会自动把请求派发[dispatch]到合适的逻辑）。
        **具体实现：**
        通过类派生列表来实现：
        通过类派生列表明确指出该子类(派生类)是从哪些父类(基类)继承而来。
        ```cpp
        //定义父类
        class Quote
        {
            public:
                std::string isbn() const;
                virtual double net_price(std::size_t) const;
        };
        //定义子类，子类从父类Quote继承
        class Bulk_quote:public Quote
        {
            public:
            double net_price(std::size_t) const override;
        };
        ```
        
        通过虚函数(virtual function)来实现：
        对于某些函数(方法)，基类希望它的派生类(子类)各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数**。
        意为如果父类想让子类的方法和自己的方法不完全同于父类，那么父类需要把该方法设为虚方法，从而子类可以重新改写该方法，而不是直接继承(不标明虚方法的方法会直接被子类继承)。




    3. 多态：
        **注解：**
        基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。

参考资料：https://www.zhihu.com/question/20275578/answer/26577791

    ```
    未详细讲解的
    1. 拷贝、赋值和析构 p239
    2. =default p237
    ```
    
###  #侯捷视频
    虚函数与多态：
    函数的继承继承的是调用权，子类可以继承父类的函数指的是子类继承了父类函数的调用权。
    子类用不用重新定义父类的函数？
    成员函数分为三种：
    第一种是非虚函数，你不希望子类(派生类)override(覆写)重新定义该函数
    第二种是虚函数，你希望子类去重新定义该函数，而且你对该函数有默认的定义
    第三种是纯虚函数，你希望子类一定要重新定义该函数，子类不可以不定义该函数，你对该函数没有默认定义

    


穿插一点p695内容
命名空间：